= Argo
:favicon:
:source-highlighter: rouge
:icons: font
// :toc: left
:toclevels: 1
:description: Argo is an open source JSON parser and generator compliant with RFC 7159 written in Java.  It offers document, push, and pull APIs.
:source-roots: {docfile}/../java

Argo is a free, open source JSON parsing and generating library for Java.

Argo is compliant with https://datatracker.ietf.org/doc/html/rfc8259[RFC 8259].
It works with Java 5 onwards, and includes JPMS module information for Java 9 onwards.
Argo has no dependencies.

// TODO document parser limitations, per https://datatracker.ietf.org/doc/html/rfc8259#section-9

== Downloads

Argo is published on https://central.sonatype.com/artifact/net.sourceforge.argo/argo[Maven Central].

[tabs]
====
Gradle (Kotlin)::
+
--
[source,kotlin,subs="+attributes"]
----
dependencies {
    implementation(group = "net.sourceforge.argo", name = "argo", version = "{revnumber}")
}
----
--

Gradle (Groovy)::
+
--
[source,groovy,subs="+attributes"]
----
dependencies {
    implemenation group: 'net.sourceforge.argo', name: 'argo', version: '{revnumber}'
}
----
--

Maven::
+
--
[source,xml,subs="+attributes"]
----
<dependency>
    <groupId>net.sourceforge.argo</groupId>
    <artifactId>argo</artifactId>
    <version>{revnumber}</version>
</dependency>
----
--
====

== Usage

Let's generate a JSON document to represent a blog entry.

[source,java]
----
include::{docfile}/../../java/argo/ExamplesTest.java[tags=generateSomeJson,indent=0]
----

<1> Static factory methods in `argo.jdom.JsonNodeFactories` model JSON

Our blog entry JSON looks like this:

[source,json]
----
include::{docfile}/../../java/argo/ExamplesTest.java[tags=generateSomeJsonResult,indent=0]
----

To retrieve the title from the blog entry JSON we produced, we parse it, and then extract the value of the `title` field.

[source,java]
----
include::{docfile}/../../java/argo/ExamplesTest.java[tags=parseSomeJson,indent=0]
----

=== Streaming

Suppose we want to add an array of comments retrieved from a data source to our blog entry JSON.
To avoid reading all the comments into memory at once, and to begin outputting JSON text as early as possible, we can use streaming.

[source,java]
----
include::{docfile}/../../java/argo/ExamplesTest.java[tags=streamOutSomeJson;!streamOutSomeJsonIntermediateResultWrapper,indent=0]
----

<1> Get a source of comments
<2> A `StringWriter` for demonstration purposes, but could be any `Writer`
<3> At this point, the `StringWriter` has already received:
+
[source,json]
----
include::{docfile}/../../java/argo/ExamplesTest.java[tags=streamOutSomeJsonIntermediateResult,indent=0]
----
<4> The `Iterable` of comments can be unbounded; our code only keeps one comment in memory at a time

To retrieve the comments from the JSON we just made without having to hold it all in memory, we can use streaming again.

[source,java]
----
include::{docfile}/../../java/argo/ExamplesTest.java[tags=streamInSomeJson,indent=0]
----

<1> A `StringReader` for demonstration purposes, but could be any `Reader`
<2> The stack will keep track of the parents of the current element
<3> Nodes' text is also streamed, so we can have unbounded strings, numbers, and field names

== Limitations

[cols=",,,,"]
|===
|
|parse
|streaming parse
|generate
|streaming generate

|Characters in a string
|`Integer.MAX_VALUE` - 8
|Unlimited
|`Integer.MAX_VALUE` - 8
|Unlimited

|Characters in a number
|`Integer.MAX_VALUE` - 8
|Unlimited
|`Integer.MAX_VALUE` - 8
|Unlimited

|Elements in an array
|`Integer.MAX_VALUE` - 8
|Unlimited
|`Integer.MAX_VALUE` - 8
|Unlimited

|Fields in an object
|`Integer.MAX_VALUE` / 8
|Unlimited
|`Integer.MAX_VALUE` - 8
|Unlimited

|Nesting depth
|Limited by JVM stack (>3000 using 1MB stack)
// TODO this is probably now memory limited.
|`Integer.MAX_VALUE` - 8
|Limited by JVM stack (>2000 using 1MB stack)
|Limited by JVM stack (>3000 using 1MB stack)

|===
